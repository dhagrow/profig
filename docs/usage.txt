Guide
=====

Keys
----

A :class:`~profig.Config` object can be used directly without any initialization::
    
    import profig
    cfg = profig.Config()
    cfg['server.host'] = '8.8.8.8'
    cfg['server.port'] = 8181

Configuration keys are :samp:`.` delimited strings where each preceding name
refers to a section, and the final name refers to a key with a value. In
the example above, `server` is a section name, while `host` and `port` are
keys within the section.

For a quick look at the hierarchical structure of the options, you can easily
get the dict representation::
    
    >>> cfg.as_dict()
    {'server': {'host': '8.8.8.8', 'port': 8181}}

Initialization
--------------

One of the most useful features of the :mod:`profig` library is the ability
to initialize the options that are expected to be set on a
:class:`~profig.Config` object.

If you were to sync the following config file without any initialization::

    server.host: 127.0.0.1
    server.port: 8080

The port number would be interpreted as a string, and you would have to
convert it manually. You can avoid doing this each time you access the value
by using the :meth:`~profig.Config.init` method::
    
    >>> cfg.init('server.host', '127.0.0.1')
    >>> cfg.init('server.port', 8080, int)

The second argument to :meth:`~profig.Config.init` specifies a default
value for the option. The third argument is optional and is used by the
:mod:`coerce` module to automatically (de)serialize any value that is set
for the option. If the third is not provided, the type of the default value
will be used to select the correct coercer.

Nested Sections
---------------

Values can be organized and accessed in hierarchies::
    
    >>> cfg['server.port']
    8080
    >>> cfg.section('server').as_dict()
    {'host': 'localhost', 'port': 8080}

Automatic Typing (Coercion)
---------------------------

Type information can be applied by initializing a key with a default value::
    
    >>> cfg.init('server.port', 8080)
    >>> cfg.sync()
    >>> port = cfg['server.port']
    >>> port
    9090
    >>> type(port)
    <class 'int'>

An alternate type can by specified as the third argument::
    
    >>> cfg.init('editor.open_files', [], 'path_list')

Now, supposing we have the following in a config file::
    
    editor.open_files: profig.py:test_profig.py

We can the sync the config file, and access the stored value::

    >>> cfg.sync()
    >>> cfg['editor.open_files']
    ['profig.py', 'test_profig.py']

We can look at how the value is stored in the config file by using the
section directly::

    >>> sect = cfg.section('editor.open_files')
    >>> sect.value(convert=False)
    'profig.py:test_profig.py'

Adding Coercers
---------------

Functions that define how an object is adapted (object -> string) or converted
(string -> object) are referred to as "coercers". They can be defined using
a :class:`~profig.Coercer` object that is accessible as an attribute of the root
:class:`~profig.Config` object.

Defining a new coercer (or overriding an existing one) is as simple as passing
two functions to :meth:`~profig.Coercer.register`. For example, a simple
coercer for a *bool* type could be defined like this::
    
    >>> cfg.coercer.register(bool, lambda x: str(int(x)), lambda x: bool(int(x)))

The first argument to :meth:`~profig.Coercer.register` is a value that will be
used to determine the correct coercer to use. A class object, when available, is
most convenient, because it allows using a call to `type(obj)` to determine
which coercer to use. However, any value can be used for the registration,
including, e.g. strings or tuples.

Using Coercers as Validators
----------------------------

By default, a coercer will only raise exceptions if there is a fundamental
incompatibility in the values it is trying to coerce. They can easily be
defined or overridden, however, to raise exceptions for unexpected ranges of
inputs or other restrictions that should be in place for a given configuration
value.

Synchronization
---------------

A sync is a combination of the read and write operations, executed in the
following order:
    
    1. Read in any changed values from a source, unless a value has changed
       on the config object since the last time it was synced.
    2. Write any values changed on the config object back to the primary
       source.

The configuration can be serialized using the :meth:`~profig.Config.sync`
method::

    >>> cfg.sync('app.cfg')

After the call to :meth:`~profig.Config.sync`, a new file with the following
contents will be created in the current working directory::

    server.host: 127.0.0.1
    server.port: 8080

Sources
-------

The sources a config object uses when it syncs can also be set in the
:class:`~profig.Config` constructor::
    
    >>> cfg = profig.Config('app.cfg')

Sources can be either paths or file objects.

If more than one `source` is provided then a sync will update the config
object with values from each of the sources in the order given. Then it will
write values changed on the config object back to the first source.

Once sources have been provided, they will be used for any future syncs.

    >>> cfg.sync()

Formats
-------

A :class:`~profig.Format` subclass defines how a configuration should be
read/written from/to a source.

The following formats are available:
    
:class:`~profig.FigFormat`
    The default format. Simple but expressive::
    
        server.host: localhost
        server.port: 8080

:class:`~profig.IniFormat`
    Mostly standard INI format. An INI section will be created for each
    subsection in the config object.

Support for additional formats can be added easily by subclassing
:class:`~profig.Format`.

Defining a new Format
~~~~~~~~~~~~~~~~~~~~~

To add support for a new format you must subclass :meth:`~profig.Format` and
override the, :meth:`~profig.Format.read` and :meth:`~profig.Format.write`
methods.

Read should return a `(values, context)` tuple. *values* must be a dict that
maps keys to string values. Any *context* that is returned will be passed to
:meth:`~profig.Format.write` during a sync. It can be used, for example, to
track comments and ordering of the source. `None` can be returned if no context
is needed.

Write accepts a dict of values from the :class:`~profig.Config` object and any
context returned from a call to :meth:`~profig.Format.read`.

Unicode
-------

*profig* fully supports unicode. The encoding to use for all
encoding/decoding operations can be set in the :class:`~profig.Config`
constructor::
    
    >>> cfg = profig.Config(encoding='utf-8')

The default is to use the system's preferred encoding.

Keys are handled in a special way. Both byte-string keys and unicode keys
are considered equivalent, but are stored internally as unicode keys. If
a byte-string key is used, it will be decoded using the configured encoding.

Values are coerced into a unicode representation before being output to a
config file. Note that this means that by specifically storing a byte-string
as a value, *profig* will assume the value is binary data. The default
coercer for byte-strings converts the value to a hex string.

So, if we consider the following examples using a Python 2 interpreter,
where `str` objects are byte-strings::
    
    >>> cfg['a'] = 'asdf'

Will be stored to a config file as::
    
    a: 61736466

If this is not the desired behavior, there are two options. First, we can
set the type of the value to `unicode` using :meth:`~profig.Config.init`::
    
    >>> cfg.init('a', 'asdf', unicode)

Or, we can register different coercers for byte-strings::
    
    >>> cfg.coercer.register(str, str, str)
