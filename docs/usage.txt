Usage Guide
===========

A :class:`~config.Config` object can be used directly without any initialization::
    
    import config
    cfg = config.Config()
    cfg['server.host'] = '8.8.8.8'
    cfg['server.port'] = 8181

Configuration keys are :samp:`.` delimited strings where each preceding name
refers to a section, and the final name refers to a key with a value. In
the example above, `server` is a section name, while `host` and `port` are
keys within the section.

For a quick look at the hierarchical structure of the options, you can easily
get the dict representation::
    
    >>> print(cfg.as_dict())
    {'server': {'host': '8.8.8.8', 'port': 8181}}

Synchronization
---------------

A sync is a combination of the read and write operations, executed in the
following order:
    
    1. Read in any changed values from a source, unless a value has changed
       on the config object since the last time it was synced.
    2. Write any values changed on the config object back to the primary
       source.

The configuration can be serialized using the :meth:`~config.Config.sync`
method::

    >>> cfg.sync('app.cfg')

After the call to :meth:`~config.Config.sync`, a new file with the following
contents will be created in the current working directory::

    server.host: 127.0.0.1
    server.port: 8080

Sources
-------

The sources a config object uses when it syncs can also be set in the
:class:`~config.Config` constructor::
    
    >>> cfg = config.Config('app.cfg')

Sources can be either paths or file objects.

If more than one `source` is provided then a sync will update the config
object with values from each of the sources in the order given. Then it will
write values changed on the config object back to the first source.

Formats
-------

The default output format is a simple list of "section.key = value" lines. The
format to use can be set either in the call to :meth:`~config.Config.sync` or
in the :class:`~config.Config` constructor.

The following formats are available:
    
:class:`~config.ConfigFormat`
    The default format. Simple but expressive.

:class:`~config.IniFormat`
    Mostly standard INI format. An INI section will be created for each
    subsection in the config object.
    
:class:`~config.JsonFormat`
    Standard JSON format.
    
:class:`~config.PickleFormat`
    Dumps straight to pickle files.

Support for additional formats can be added easily by subclassing
:class:`~config.BaseFormat`.

Initialization
--------------

One of the most useful features of the :mod:`config` module is the ability
to initialize the options that are expected to be set on a
:class:`~config.Config` object.

If you were to sync the following config file without any initialization::

    server.host = 127.0.0.1
    server.port = 8080

The port number would be interpreted as a string, and you would have to
convert it manually. You can avoid doing this each time you access the value
by using the :meth:`~config.Config.init` method::
    
    >>> cfg.init('server.host', '127.0.0.1')
    >>> cfg.init('server.port', 8080, int)

The second argument to :meth:`~config.Config.init` specifies a default
value for the option. The third argument is optional and is used by the
:mod:`coerce` module to automatically (de)serialize any value that is set
for the option. If the third is not provided, the type of the default value
will be used to select the correct coercer.

Coercion
--------

Coercion is the automatic de/serialization of values::
    
    >>> cfg.init('server.port', 8080)
    >>> cfg.sync()
    >>> port = cfg['server.port']
    >>> print(port, type(port))
    9090 <class 'int'>

Nested Sections
---------------

Values can be organized into hierarchies::
    
    >>> print(cfg.section('server').as_dict())
    {'host': 'localhost', 'port': 8080}

Format Strings
--------------

:class:`~config.Config` objects can be used directly in format strings in
several ways::
    
    >>> '{0[server.host]}:{0[server.port]}'.format(cfg)
    localhost:8080
    >>> '{c[server.host]}:{c[server.port]}'.format(c=cfg)
    localhost:8080
    >>> '{host}:{port}'.format(**c.section('server'))
    localhost:8080
